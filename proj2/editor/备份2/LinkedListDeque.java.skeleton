/**
 * Created by Administrator on 2016/7/22.
 */
package editor;

import javafx.scene.text.Text;
import java.lang.reflect.Array;
import groovy.swing.factory.LineBorderFactory;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class LinkedListDeque<Item> {
    private int size = 0;
    public List sentinel;
    private List P;//pointer   delete
    private List CurrentPos;
    public ArrayDeque<List> LineFirsts = new ArrayDeque<>();
    public ArrayDeque<List> LineFirstsArtificial = new ArrayDeque<>();
    public ArrayDeque<List> LineFirstsTotal = new ArrayDeque<>();

    //: Creates an empty linked list deque.
    //this runs when the LinkedListDeque class is instantiated.
    public LinkedListDeque() {
        sentinel = new List(null, null, null);
        sentinel.next = sentinel;
        sentinel.prev = sentinel;
        P = sentinel;//delete
        LineFirsts.addFirst(sentinel);
    }

    //}
    //create list
    public class List {
        public List next;
        public List prev;
        public Item items;

        //add an item at the specified place.
        public List(Item itm, List p, List n) {
            items = itm;
            prev = p;
            next = n;
        }
    }

    //: Adds an item to the front of the Deque.
    public void addFirst(Item itm) {
        List pointer = sentinel.next;
        List first = new List(itm, sentinel, sentinel.next);
        sentinel.next = first;
        pointer.prev = first;
        size += 1;
    }

    //: Adds an item to the back of the Deque.
    public void addLast(Item itm) {
        List pointer = sentinel.prev;
        List last = new List(itm, sentinel.prev, sentinel);
        sentinel.prev = last;
        pointer.next = last;
        size += 1;
    }
    /**add at pos*/
    public void addAtPos(List Pos, Item itm){
        List Posnext = Pos.next;
        List addList = new List(itm, Pos, Pos.next);
        Pos.next = addList;
        Posnext.prev = addList;
    }


    //: Returns true if deque is empty, false otherwise.
    public boolean isEmpty() {
        if (sentinel.next.items == null) {
            return true;
        } else {
            return false;
        }
    }

    //: Returns the number of items in the Deque.
    public int size() {
        return size;
    }

    //: Prints the items in the Deque from first to last, separated by a space.
    public void printDeque() {
        int i = 0;
        List pointer = sentinel.next;
        while (i != size) {
            System.out.print(pointer.items + " ");
            i += 1;
        }
    }

    //: Removes and returns the item at the front of the Deque.
    // If no such item exists, returns null.
    public Item removeFirst() {
        if (sentinel.next == null) {
            return null;
        }
        List pointer = sentinel.next.next;
        Item a = sentinel.next.items;
        sentinel.next.items = null;
        sentinel.next = pointer;
        pointer.prev = sentinel;
        size -= 1;
        return a;
    }

    //: Removes and returns the item at the back of the Deque.
    // If no such item exists, returns null.
    public Item removeLast() {
        if (sentinel.prev == null) {
            return null;
        }
        List pointer = sentinel.prev.prev;
        Item a = sentinel.prev.items;
        sentinel.prev.items = null;
        sentinel.prev = pointer;
        pointer.next = sentinel;
        size -= 1;
        return a;
    }

    //: Gets the item at the given index, where 0 is the front, 1 is the next item, and so forth.
    // If no such item exists, returns null. Must not alter the deque!
    public Item get(int index) {
        //iteratively
        if (index > size - 1) {
            return null;
        }
        List pointer = sentinel.next;
        int i = 0;
        while (i != index) {
            pointer = pointer.next;
            i+=1;
        }
        return pointer.items;
    }

    //: Same as get, but uses recursion.
    public Item getRecursive(int index) {
        if (index > size - 1) {
            return null;
        }
        P = P.next;
        if (index!=0) {
            return getRecursive(index-1);
        } else {
            return P.items;
        }
    }

    public class ArrayDeque<Item> {
        public int size = 8;//initial spaces
        public int numbers = 0;//number of items
        public int nextFirst;
        public int nextLast;
        public Item[] items;

        //: Creates an empty linked list deque.
        //this runs when the LinkedListDeque class is instantiated.
        public ArrayDeque() {
            items = (Item[]) new Object[8];//different when instantiating a generic array.
            nextFirst = 0;
            nextLast = 1;
        }

        //add out of size
        public Item[] reSize() {
            int inisize = size;
            size *= 2;//final size
            Item[] newitems = (Item[]) new Object[size];
            nextLast += 1;
            int i = nextLast;
            //nextFirst, not final yet

            while (nextLast != nextFirst + inisize) {
                if (i >= inisize) {
                    i -= inisize;
                }
                if (i < 0) {
                    i += inisize;
                }
                newitems[nextLast] = items[i];
                i += 1;

                nextLast += 1;
            }
            return newitems;
        }

        //: Adds an item to the front of the Deque.
        public void addFirst(Item itm) {
            if (nextFirst == nextLast) {
                items = reSize();//final items
            }
            items[nextFirst] = itm;
            nextFirst = nextFirst - 1;//final nextFirst
            if (nextFirst < 0) {
                nextFirst += size;
            }
            numbers += 1;//final numbers
        }


        //: Adds an item to the back of the Deque.
        public void addLast(Item itm) {
            if (nextFirst == nextLast) {
                items = reSize();//final items
            }
            items[nextLast] = itm;
            nextLast = nextLast + 1;
            if (nextLast >= size) {
                nextLast -= size;
            }
            numbers += 1;
        }


        //: Returns true if deque is empty, false otherwise.
        public boolean isEmpty() {
            if (numbers == 0) {
                return true;
            } else {
                return false;
            }
        }

        //: Returns the number of items in the Deque.
        public int size() {
            return numbers;
        }

        //: Prints the items in the Deque from first to last, separated by a space.
        public void printDeque() {
            int i = nextFirst + 1;
            while (i != nextLast) {
                if (i >= size) {
                    i = i - size;
                }
                System.out.print(items[i] + " ");
                i += 1;
            }
        }

        //resize when memory is not effeciently used
        public Item[] reSizeSmaller() {
            if (size / numbers < 4) {
                return items;
            } else {
                int inisize = size;
                if (size / 2 >= 8) {
                    size /= 2;
                } else {
                    size = 8;
                }//final size

                Item[] newitems = (Item[]) new Object[size];
                int i = nextFirst + 1;
                nextFirst = 0;
                nextLast = 1;

                while (nextLast != numbers + 1) {
                    if (i >= inisize) {
                        i -= inisize;
                    }
                    if (i < 0) {
                        i += inisize;
                    }
                    newitems[nextLast] = items[i];
                    i += 1;
                    nextLast += 1;
                }
                return newitems;
            }
        }

        //: Removes and returns the item at the front of the Deque.
        // If no such item exists, returns null.
        public void removeFirst() {
            items = reSizeSmaller();
            nextFirst += 1;
            if (nextFirst >= size) {
                nextFirst -= size;
            }
            items[nextFirst] = null;
            numbers -= 1;
        }

        //: Removes and returns the item at the back of the Deque.
        // If no such item exists, returns null.
        public void removeLast() {
            items = reSizeSmaller();
            nextLast -= 1;
            if (nextLast < 0) {
                nextLast += size;
            }
            items[nextLast] = null;
            numbers -= 1;
        }

        //: Gets the item at the given index, where 0 is the front, 1 is the next item, and so forth.
        // If no such item exists, returns null. Must not alter the deque!
        public Item get(int index) {
            if (index > numbers - 1) {
                return null;
            }
            int i = 0;
            int m = nextFirst + 1;
            if (m >= size) {
                m -= size;
            }
            while (i != index) {
                i += 1;
                m += 1;
                if (m >= size) {
                    m -= size;
                }
            }
            return items[m];
        }


    }

    /**first is outputfilename, seconde is output strings*/
    public void SaveFile(String args){
        String outputFilename = args;
        // Create a FileWriter to write to outputFilename. FileWriter will overwrite any data
        // already in outputFilename.
        try {
            FileWriter writer = new FileWriter(outputFilename);

            List position;
            position=sentinel.next;

            /**use stirngbuilder to convert Character to string.*/
            StringBuilder stringbuilder = new StringBuilder(size);
            while (position.items != null){
                stringbuilder.append(position.items);
                position = position.next;
            }
            String output = stringbuilder.toString();
            writer.write(output);

            System.out.println("Successfully saved file to "
                    + outputFilename);

            writer.close();
        }catch (FileNotFoundException fileNotFoundException) {
            System.out.println("File not found! Exception was: " + fileNotFoundException);
        }catch (IOException ioException){
            System.out.println("Error when copying; exception was: " + ioException);
        }
    }

    /**when there is a newline, create a new List that items point at \n*/
    public void NewLineAndArrayitem(List newline){
        LineFirsts.addLast(newline);
        LineFirstsTotal.addLast(newline);
    }
    public void NewArtificialLine(List newline){
        LineFirstsArtificial.addLast(newline);
        LineFirstsTotal.addLast(newline);
    }
    /**item number of List LineFirsts*/
    public int LineFirstsNumber(){
        return LineFirsts.size();
    }
    /**print next item of every item in Array LineFirsts \n*/
    public void printlineItem(){
        int i = 0;
        while (i!=LineFirstsNumber()) {
            System.out.print(i);
            System.out.println(LineFirsts.get(i).items);
            i+=1;
        }
    }
    /**get the address of the last LIST!!!! in the linkedlist*/
    public List getLast(){
        return sentinel.prev;
    }
    public ArrayDeque removeNull(){
        /**and linefirsttotal linefirstsartificial*/
        return removeNull(LineFirsts,1);
    }
    /**
     * check if the lineFirsts array contains null, if so, remove it.
     */
    private ArrayDeque<List> removeNull(ArrayDeque<List> LineFirst, int start) {
        if (start <= LineFirst.numbers - 1) {
            if (LineFirst.get(start).items == null) {
                int a = LineFirst.numbers-1;
                int i = 0;

                GenSet temp = new GenSet(LineFirst.numbers);
                /**2 situations:1.the last is removed, 2. item in the middle is removed.*/
                if (a != start) {
                    while (a != start) {
                        temp.put(LineFirst.get(i),i);
                        removeLast();
                        a -= 1;
                        i += 1;
                    }
                    int j = 0;
                    int k = i;
                    while (j != i) {
                        LineFirst.addLast((List) temp.get(k - 1));
                        k -= 1;
                        j += 1;
                    }
                }else {LineFirst.removeLast();}
                //System.out.print(" remove");
            }
            start+=1;
            return removeNull(LineFirst,start);
        }else {
            //System.out.print(" end2 "+LineFirst.numbers+"\n");
            return LineFirst;
        }
    }
    private class GenSet<List> {
        /**this is an array of class List*/
        public Object[] obj;

        public GenSet(int s) {
            obj = new Object[s];
        }

        void put(List listA,int i) {
            obj[i] = listA;
        }
        List get(int i) {
            return (List) obj[i];
        }
    }
    /**determine the location of wrap*/
    public void WrapLocation(){

    }
    /**wrap*/
    public void Wrap(Item newline1, Item newline2){
        /**this is left to revise*/
        System.out.print(LineFirsts.numbers);
        System.out.print(LineFirsts.get(LineFirsts.numbers-1).next.items);

        Wrapdistance(LineFirsts.get(LineFirsts.numbers-1),newline1,newline2);
    }
    /**count the length of a line, from \n to \r*/
    public void Wrapdistance(List start, Item newline1, Item newline2){
        int i = 0;
        int wordlength = 0;
        while (wordlength<500){
        char readchar = CharacterTochar((Character) start.next.items);
            if  (readchar ==13)
            {return;}
            wordlength+=textbuilder((Character) start.items).getLayoutBounds().getWidth();
            i+=1;
            start=start.next;
        }
        char readchar = CharacterTochar((Character) start.items);
        while (readchar!=32){
            i-=1;
            start=start.prev;
            readchar = CharacterTochar((Character) start.items);
        }
        WrapAtPos(start, newline1);
        WrapAtPos(start, newline2);//start is now the position of the space
    }
    /**do the wrap*/
    public void WrapAtPos(List Pos, Item newline){
        /** add newline after the nearest space on the left*/
        this.addAtPos(Pos,newline);
        this.NewArtificialLine(this.getLast());
    }
    /**convert Character to Text*/
    private Text textbuilder(Character C){
        StringBuilder stringbuilder = new StringBuilder(1);
        stringbuilder.append(C);
        String output = stringbuilder.toString();
        Text temptext = new Text();
        temptext.setText(output);
        return temptext;
    }
    private char CharacterTochar(Character C){
        StringBuilder sb = new StringBuilder(1);
        sb.append(C);
        String tempstring = sb.toString();
        char result = tempstring.charAt(0);
        return result;
    }
}
